<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>What Happens When You Run a Spring Boot Application?</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/black.css" id="theme">
		<link rel="stylesheet" href="css/custom.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css" id="highlight-theme">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section data-markdown data-separator-notes="^Note:">
				What Happens When You Run a Spring Boot Application?

				Note:
				This will be focused mostly towards people with intermediate experience with Spring Boot. 
				If you're intermediate or advanced, you will likely be familiar with some, if not all, of the concepts I'll cover and 
				demonstrate. I'm aiming for the middle - the people who have used Spring Boot for a while, but often times feel like they're programming by coincidence - it works, but do I know why it works?
				Do I know what just happened when I coppied this SO answer? 
				</section>
				<section>
					<section data-markdown="markdown/event-list.md" class="lower-font"></section>
					<section data-markdown="markdown/events-annex.md" class="lower-font"></section>
				</section>
				<section data-markdown data-separator-notes="^Note:" class="lower-font">
					### `ApplicationContext` + `BeanFactory`
					`BeanFactory` - provides the configuration framework and basic functionality.
					
					`ApplicationContext` - adds more enterprise-specific functionality. A complete superset of the `BeanFactory`.

					Note: 
					You should use an ApplicationContext unless you have a good reason for not doing so, 
					with GenericApplicationContext and its subclass AnnotationConfigApplicationContext as the common implementations for custom bootstrapping.
					
					In SpringBoot's case, we don't really care about which one is used, since it is configured for us.

					The internal state of Spring Boot applications is mostly represented by the Spring ApplicationContext.

					If the application context has started successfully, Spring Boot assumes that the application is in a valid state.

					Typically, an application developer does not need to subclass ApplicationContext implementation classes. 
					Instead, the Spring IoC container can be extended by plugging in implementations of special integration interfaces.
				</section>
				<section>
					<section data-markdown data-separator-notes="^Note:" class="lower-font">
						### `Environment`
	
						The `Environment` interface is an abstraction integrated in the container that models two key aspects of the application environment: `profiles` and `properties`.
						
						* The role of the `Environment` object with relation to profiles is in determining which profiles (if any) are currently active, and which profiles (if any) should be active by default.
	
						* The role of the `Environment` object with relation to properties is to provide the user with a convenient service interface for configuring property sources 
						and resolving properties from them.
					</section>
					<section data-markdown data-separator-notes="^Note:" class="lower-font">
						### Adding custom `PropertySources` to the `Environment`
						#### Using `@PropertySources`

						```java
						@Configuration
						@PropertySource("classpath:/com/myco/app.properties")
						public class AppConfig {

							@Autowired
							Environment env;

							@Bean
							public TestBean testBean() {
								TestBean testBean = new TestBean();
								testBean.setName(env.getProperty("testbean.name"));
								return testBean;
							}
						}
						```

						Note:
						A PropertySource is a simple abstraction over any source of key-value pairs, 
						and Spring’s StandardEnvironment is configured with two PropertySource objects — 
						one representing the set of JVM system properties (System.getProperties()) and one representing the set of system environment variables (System.getenv()).
						
						While using @PropertySource on your @SpringBootApplication may seem to be a convenient way to load a custom resource in the Environment, 
						we do not recommend it. Such property sources are not added to the Environment until the application context is being refreshed. 
						This is too late to configure certain properties such as logging.* and spring.main.* which are read before refresh begins.
					</section>
					<section data-markdown data-separator-notes="^Note:" class="lower-font">
						### Adding custom `PropertySources` to the `Environment`
						#### Manually registering with the context
						
						```java
						ConfigurableApplicationContext ctx = // some way to get the context - could be through an application event, or by implementing ApplicationContextAware, etc.
						MutablePropertySources sources = ctx.getEnvironment().getPropertySources();
						sources.addFirst(new MyPropertySource());
						```

						Note: 
						It is also possible to customize the Environment before the application context is refreshed by using EnvironmentPostProcessor
					</section>
					<section data-markdown="markdown/environment-property-sources.md" data-separator-notes="^Note:" class="lower-font">
					</section>
				</section>
				<section data-markdown="initializers_listeners.md" data-separator-notes="^Note:" class="lower-font"></section>
				<section>
					<section data-markdown="bean_definitions.md" data-separator-notes="^Note:" class="lower-font"></section>
					<section data-markdown="bean_definitions2.md" data-separator-notes="^Note:" class="lower-font"></section>
				</section>
				<section data-markdown="markdown/context-refresh.md" data-separator-notes="^Note:" class="lower-font"></section>

				<section data-markdown="markdown/application-command-line-runners.md" data-separator-notes="^Note:" class="lower-font"></section>

				<section data-markdown data-separator-notes="^Note:" class="lower-font">
					### Liveness state and Readiness State

					The `Livenes` state of an application tells whether its internal state allows it to work correctly, or recover by itself if it’s currently failing.
					A broken `Liveness` state means that the application is in a state that it cannot recover from, and the infrastructure should restart the application.

					The `Readiness` state of an application tells whether the application is ready to handle traffic. 
					A failing `Readiness` state tells the platform that it should not route traffic to the application for now. 

					Note:
					For liveness:
					The internal state of Spring Boot applications is mostly represented by the Spring ApplicationContext. 
					If the application context has started successfully, Spring Boot assumes that the application is in a valid state.
					An application is considered live as soon as the context has been refreshed.

					For readiness:
					This typically happens during startup, while `CommandLineRunner` and `ApplicationRunner` components are being processed, 
					or at any time if the application decides that it’s too busy for additional traffic.
				</section>
				<section>Enough talk, more action! Let's demo!</section>
				<section data-separator-notes="^Note:" >
					<img src="images/SpringBootLifecycle.png">
					<aside class="notes">
						Before we do that, let's help us set the scene by providing a visual representation of the entire event flow we just went over.
					</aside>
				</section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,
				disableLayout: false,
				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
